# MySQL 索引快速入门

## 1. 什么是索引？

索引就像书的目录，帮助数据库快速找到数据。没有索引时，数据库需要逐行扫描整个表；有了索引，可以直接定位到数据位置。

**简单比喻：**
- 没有索引：像在没有目录的书中逐页查找内容
- 有索引：像通过书的目录快速跳转到指定页面

## 2. 索引类型

### 2.1 主键索引（PRIMARY KEY）
- 每个表只能有一个主键索引
- 自动创建，唯一且不能为空
- 查询速度最快

### 2.2 唯一索引（UNIQUE）
- 保证列值唯一性
- 可以有多个唯一索引
- 允许一个NULL值

### 2.3 普通索引（INDEX）
- 最基本的索引类型
- 没有唯一性限制
- 提高查询速度

### 2.4 复合索引
- 多个列组合创建的索引
- 遵循最左前缀原则

## 3. 索引使用场景

### 适合创建索引的情况：
- 经常用于WHERE条件查询的列
- 经常用于ORDER BY排序的列
- 经常用于JOIN连接的列
- 数据量大的表

### 不适合创建索引的情况：
- 数据量很小的表
- 经常进行增删改操作的列
- 重复值很多的列（如性别字段）

## 4. 索引语法

### 4.1 创建索引

```sql
-- 创建普通索引
CREATE INDEX 索引名 ON 表名(列名);

-- 创建唯一索引
CREATE UNIQUE INDEX 索引名 ON 表名(列名);

-- 创建复合索引
CREATE INDEX 索引名 ON 表名(列名1, 列名2);

-- 在创建表时创建索引
CREATE TABLE 表名 (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    email VARCHAR(100),
    INDEX idx_name (name),
    UNIQUE INDEX idx_email (email)
);
```

### 4.2 查看索引

```sql
-- 查看表的所有索引
SHOW INDEX FROM 表名;

-- 查看表结构（包含索引信息）
DESC 表名;

-- 查看创建表的SQL语句
SHOW CREATE TABLE 表名;
```

### 4.3 删除索引

```sql
-- 删除索引
DROP INDEX 索引名 ON 表名;

-- 删除主键索引
ALTER TABLE 表名 DROP PRIMARY KEY;
```

## 5. 实战演示

### 5.1 创建测试数据

```sql
-- 创建测试数据库
CREATE DATABASE index_demo;
USE index_demo;

-- 创建用户表（无索引版本）
CREATE TABLE users_no_index (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100),
    age INT,
    city VARCHAR(50),
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 创建用户表（有索引版本）
CREATE TABLE users_with_index (
    id INT AUTO_INCREMENT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100),
    age INT,
    city VARCHAR(50),
    created_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_username (username),
    INDEX idx_email (email),
    INDEX idx_age (age),
    INDEX idx_city (city)
);
```

### 5.2 插入测试数据

```sql
-- 插入10万条测试数据的存储过程
DELIMITER //
CREATE PROCEDURE insert_test_data()
BEGIN
    DECLARE i INT DEFAULT 1;
    DECLARE batch_size INT DEFAULT 1000;
    
    WHILE i <= 100000 DO
        INSERT INTO users_no_index (username, email, age, city) VALUES
        (CONCAT('user', i), CONCAT('user', i, '@example.com'), 
         FLOOR(18 + RAND() * 50), 
         CASE FLOOR(RAND() * 5)
             WHEN 0 THEN '北京'
             WHEN 1 THEN '上海'
             WHEN 2 THEN '广州'
             WHEN 3 THEN '深圳'
             ELSE '杭州'
         END);
         
        INSERT INTO users_with_index (username, email, age, city) VALUES
        (CONCAT('user', i), CONCAT('user', i, '@example.com'), 
         FLOOR(18 + RAND() * 50), 
         CASE FLOOR(RAND() * 5)
             WHEN 0 THEN '北京'
             WHEN 1 THEN '上海'
             WHEN 2 THEN '广州'
             WHEN 3 THEN '深圳'
             ELSE '杭州'
         END);
         
        SET i = i + 1;
        
        -- 每1000条提交一次，提高插入效率
        IF i % batch_size = 0 THEN
            COMMIT;
        END IF;
    END WHILE;
END //
DELIMITER ;

-- 执行存储过程插入数据
CALL insert_test_data();
```

### 5.3 性能对比测试

```sql
-- 开启查询时间显示
SET profiling = 1;

-- 测试1：根据用户名查询（精确查询）
-- 无索引表
SELECT * FROM users_no_index WHERE username = 'user50000';
-- 查看执行时间
SHOW PROFILES;

-- 有索引表
SELECT * FROM users_with_index WHERE username = 'user50000';
-- 查看执行时间
SHOW PROFILES;

-- 测试2：根据年龄范围查询
-- 无索引表
SELECT * FROM users_no_index WHERE age BETWEEN 25 AND 35 LIMIT 100;
-- 查看执行时间
SHOW PROFILES;

-- 有索引表
SELECT * FROM users_with_index WHERE age BETWEEN 25 AND 35 LIMIT 100;
-- 查看执行时间
SHOW PROFILES;

-- 测试3：根据城市查询并排序
-- 无索引表
SELECT * FROM users_no_index WHERE city = '北京' ORDER BY username LIMIT 10;
-- 查看执行时间
SHOW PROFILES;

-- 有索引表
SELECT * FROM users_with_index WHERE city = '北京' ORDER BY username LIMIT 10;
-- 查看执行时间
SHOW PROFILES;

-- 查看所有查询的执行时间对比
SHOW PROFILES;

-- 关闭性能分析
SET profiling = 0;
```

**性能对比结果示例：**
```
无索引查询：Duration: 0.045623 (全表扫描)
有索引查询：Duration: 0.000234 (索引查找)
性能提升：约200倍
```

## 6. 如何查看是否使用了索引

### 6.1 使用 EXPLAIN 分析查询

```sql
-- 分析查询执行计划
EXPLAIN SELECT * FROM users_with_index WHERE username = 'user50000';
```

**EXPLAIN 结果重要字段说明：**
- `type`: 连接类型，性能从好到坏：const > eq_ref > ref > range > index > ALL
- `key`: 实际使用的索引名
- `rows`: 预估需要扫描的行数
- `Extra`: 额外信息

### 6.2 对比分析

```sql
-- 对比无索引和有索引的执行计划
EXPLAIN SELECT * FROM users_no_index WHERE username = 'user50000';
EXPLAIN SELECT * FROM users_with_index WHERE username = 'user50000';
```

**结果对比：**
- 无索引：type=ALL，rows=100000（全表扫描）
- 有索引：type=ref，rows=1，key=idx_username（使用索引）

## 7. 索引使用注意事项

### 7.1 最左前缀原则

**什么是最左前缀原则？**
复合索引（多列索引）必须从最左边的列开始使用，就像查字典一样，必须先按第一个字母排序，再按第二个字母排序。

**举例说明：**
假设有复合索引 `INDEX(username, age, city)`，相当于创建了以下索引：
- `username`
- `username + age` 
- `username + age + city`

```sql
-- 创建复合索引
CREATE INDEX idx_name_age_city ON users_with_index(username, age, city);

-- ✅ 会使用索引（从最左开始）
SELECT * FROM users_with_index WHERE username = 'user1000';
SELECT * FROM users_with_index WHERE username = 'user1000' AND age = 25;
SELECT * FROM users_with_index WHERE username = 'user1000' AND age = 25 AND city = '北京';

-- ❌ 不会使用索引（跳过了最左边的列）
SELECT * FROM users_with_index WHERE age = 25;
SELECT * FROM users_with_index WHERE city = '北京';
SELECT * FROM users_with_index WHERE age = 25 AND city = '北京';
```

### 7.2 避免索引失效

**常见导致索引失效的情况：**

1. **对索引列使用函数**
```sql
-- ❌ 使用函数会导致索引失效
SELECT * FROM users_with_index WHERE UPPER(username) = 'USER1000';
SELECT * FROM users_with_index WHERE YEAR(created_time) = 2024;

-- ✅ 正确使用
SELECT * FROM users_with_index WHERE username = 'user1000';
SELECT * FROM users_with_index WHERE created_time >= '2024-01-01' AND created_time < '2025-01-01';
```

2. **LIKE 查询以通配符开头**
```sql
-- ❌ 以 % 开头会导致索引失效（无法确定从哪里开始查找）
SELECT * FROM users_with_index WHERE username LIKE '%1000';
SELECT * FROM users_with_index WHERE username LIKE '%user%';

-- ✅ 正确使用（可以确定查找起点）
SELECT * FROM users_with_index WHERE username LIKE 'user%';
```

3. **使用 OR 连接不同列**
```sql
-- ❌ OR 连接不同列可能导致索引失效
SELECT * FROM users_with_index WHERE username = 'user1000' OR age = 25;

-- ✅ 建议改写为 UNION
SELECT * FROM users_with_index WHERE username = 'user1000'
UNION
SELECT * FROM users_with_index WHERE age = 25;
```

## 8. 实践建议

1. **合理创建索引**：不是越多越好，会影响写入性能
2. **定期分析**：使用 EXPLAIN 分析慢查询
3. **监控性能**：关注查询执行时间
4. **删除无用索引**：定期清理不使用的索引

## 9. 小结

- 索引是提高查询性能的重要工具
- 合理使用索引可以大幅提升查询速度
- 过多索引会影响写入性能
- 使用 EXPLAIN 分析查询是否使用了索引
- 遵循索引使用的最佳实践

通过以上学习，你已经掌握了 MySQL 索引的基本概念和使用方法。在实际项目中，要根据具体的查询需求来创建合适的索引。