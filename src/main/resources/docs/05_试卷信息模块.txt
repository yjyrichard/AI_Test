
1. 查询所有试卷信息条件查询接口
   接口分析：
     参数：
        status 状态 不一定传递！ 考试入口传递！
        name   名称模糊查询字段  后台管理部分的条件
     响应：
         "data": [
            {
              "id": 1,
              "name": "Java基础知识摸底测试",
              "description": "考察Java基础语法和面向对象",
              "status": "PUBLISHED",
              "totalScore": 100.00,
              "questionCount": 20,
              "duration": 120,
              "createTime": "2025-07-29T10:00:00"
            }
          ]
   业务分析：
       试卷单表的动态查询
   实现过程：
       封装LambdaQueryWrapper条件
       condition -> name（like） 和 status (eq )动态判断
       查询列表
       返回结果即可
   注意事项：
       逻辑删除
       忽略isDeleted
       跨域问题
       进行日志结果和过程输出

2. 查询试卷详情接口接口
   接口分析：
     参数： path  paperid
     响应：
          data:{
             试卷对象
             questions: [
                {
                  question:{
                     题目信息
                     paperScore -> 试卷和题目中间
                     选项集合
                     答案对象
                  }
                }
             ]
          }
   业务分析：
     单表java代码进行paper查询
     根据paperid查询题目集合（中间，题目，答案，选项）
     对题目进行排序（选择 -> 判断 -> 简答）
     进行paper题目集合赋值
   实现过程：
      单表java代码进行paper查询
      校验paper == null -> 抛异常
      根据paperid查询题目集合（中间，题目，答案，选项）
      校验题目集合 == null -> 赋空集合！ log->做好记录
      对题目进行排序（选择 -> 判断 -> 简答）
      注意：type排序，是字符类型 -》 字符 -》 对应 -》 固定的数字 1 2 3
      进行paper题目集合赋值
   注意事项：

3. 手动组卷接口
   接口分析：
     参数：
        {
          试卷信息 （名字 描述 时间  缺少： 状态 ，总题目数 ， 总分数）
          questions:{
             题目id:真实分数
             题目id:真实分数
             题目id:真实分数
             题目id:真实分数
          }
        }
     响应：
        paper
   业务分析：
     1. 完善试卷内信息 名字 描述 时间  -> 状态 ，总题目数 ， 总分数
        状态默认值： DRAFT
        总题目数： question长度
        总分数： question分数的和
     2. 完成试卷的插入 -》 主键回显 paperId
     3. questions -> 中间表集合 （题目id,试卷id,分数）
     4. 中间表集合插入 【批量插入】 -》 中间表的service对象
     5. 返回对应paper对象
   实现过程：
      1. 完善试卷内信息 名字 描述 时间  -> 状态 ，总题目数 ， 总分数
             状态默认值： DRAFT
             总题目数： question长度
             总分数： question分数的和
      2. 完成试卷的插入 -》 主键回显 paperId
      3. questions -> 中间表集合 （题目id,试卷id,分数）
         集合为空！
         给空集合，不用批量插入！ warn级别的输出！！
      4. 中间表集合插入 【批量插入】 -》 中间表的service对象
      5. 返回对应paper对象
   注意事项：
      算题目数量：  questions.values().size();
      算题目分数：  questions.values().stream().mapToLong(bigDecimal -> long).sum(); //不能用的！！ 【intStream longStream】
                  bigDecimal.add(xxx)  bigDecimal.mul...  bigDecimal.vxxx
                  questions.values().stream().reduce(BigDecimal.ZERO, BigDecimal::add);


4. 智能组卷功能接口
   接口分析：
     参数：
        {
           试卷的三个基本属性
           规则的集合：[
              {
                类型的id ,  数量 ， 分数
              },{}
           ]
        }
     响应：
        paper
   业务分析：
     试卷基本信息 + 草稿状态 进行保存 （回显试卷的id）
     注意：不能算总分和总题目数量
     循环之前，定义总分数和总题目数量
     循环规则，随机获取规则下的题目数量（有可能不足）
       每个规则下，进行总分数和题目数量的累加
       选取对应的随机题目
       【0.type类型  1. 类别中 in(question::getCategoryId,类别id集合)  id in ()
        3.打乱集合顺序（java）4.进行判断 数量和长度（math.min(x,y)） 5. 截取题目数量 】
       进行试卷题目的中间表实体集合生成
       Collections.shuffle(list);
       插入数据库
     修改试卷的基本信息（总题目数和总分数）
     返回试卷
   实现过程：
   注意事项：

5. 更新试卷信息接口
   接口分析：
     参数：
        试卷对象和选中新的题目的集合
     响应：
        成功还是失败
   业务分析：
     本次更新对一条试卷信息 -》 直接更新
     本次更新对多条中间信息 -> 先删，再插入
   实现过程：
     校验：
           名字的问题 -》 不同id 的名字不能相同！！
           ne(id,id)
           eq(name,name)
           发布状态不能更新，提示停止发布，再更新！！
     步骤1：先更新试卷属性 【名字 描述 时间 【总题目数 总分数】 】
     步骤2：更新试卷试题类信息
   注意事项：

6. 更新试卷状态接口
   接口分析：
     参数：
         path -> id
         param -> 状态
     响应：
         成功 和 失败的提示
   业务分析：
     修改目标状态为发布，必须有题目！
     正常修改
   实现过程：
   注意事项：

7.删除试卷信息接口
   接口分析：
     参数：无
     响应：
   业务分析：
     删除查看关联的数据！
     重要数据存在，删除失败！
     自己子数据，一并删除！！
   实现过程：
     查看自己的状态，非发布才可以删除
     查看考试记录表，有关系，不能删除
     删除试卷表
     删除试卷和题目的中间表
   注意事项：